      // Un player se connect
      // Un peut creer un MatchHystory au debut
      // j utiliserais l uid du match pour idnetifer la room
      //const match = new Match;

      // Creer la room avec le Match Uid et les varaibles d environnement
      
      // Si premier player join
    /*  const room: Room = {
        id: match.id,
        nb_player: 1,
        player1: client,
        player2: null,
        player1_x: 1,
        player2_x: 2,
      }*/
      // Push vers le gameService new room

        // get le User


// A FAIRE INVITATION

// Fonctions cotee server
/*
  Pas vraiment de reponse a proprement parler

  @Subscribemessage('events')
  handleEvent(@MessageBody() data: unknown): <fees>
  {
    return fees
  }

  this.io.in(chanRoomPrefix + channel.id).emit(event, content);

*/

/*
interface ServerToClients {
  noArg: () => void;
  basicEmit: (a:number, b: string, c: Buffer) => void;
  withAck: (d: string, callback: (e: number) => void) => void;
}



*/


// .in(user.socket).emit(event, content)


  /*
  @SubscribeMessage('start')
  async Start(@ConnectedSocket() client: Socket):
  {
      const U = User.findByUsername();
  }


  @SubscribeMessage('ConnectPlayer1')
  async ConnectPlayerOne()
  {

  }

  @SubscribeMessage('ConnectPlayer2')
  async ConnectPlayerTwo()
  {

  }*/

      // game.service

  // async handleConnection(client) {
  //   // A client has connected
  //   console.log('Websocket Client Connected');

  //   // Notify connected clients of current users
  //   this.server.emit('connections', client.request.session);
  // }

  // async handleDisconnect(client: Socket) {
  //   // A client has disconnected
  //   console.log('Websocket Client Disconnected');

  //   // Notify connected clients of current users
  //   this.server.sockets.emit('connections', client.id + ' DISCONNECTED');
  // }

       // if()// si la salle est vide
     //   {client.join(String(roomid);return true;}
    

