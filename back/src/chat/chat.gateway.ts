import { WebSocketGateway, WebSocketServer, SubscribeMessage } from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Channel } from 'src/entities/channel.entity';
import { Message } from 'src/entities/message.entity';
import { User } from 'src/entities/user.entity';
import { SocketService } from 'src/socket/socket.service';


@WebSocketGateway()
export class ChatGateway {

	constructor(
		private ioServ: SocketService
	) {}

  @WebSocketServer() private io: Server;

  async error(client: Socket, msg: string = ''): Promise<any> {
    await client.emit('error', msg);
    return null;
  }


  //  Processes a new message sent by a client (either to a channel or directly to a username)
  //  A Message entity in JSON format is expected as data.
  //
  //  For a direct message, omit channel and set the message <recipient> property as a partial User ( with a user login for example ) 
  //
  @SubscribeMessage('msg')
  async msg(client: Socket, data: any): Promise<Message> {
    try {
      const user = await User.findOneBy({ft_login: client.data.login});
      // data.id = undefined;  //  Supresses the message id to always consider it as a new message.
      // data.time = undefined;  //  Supresses the message timestamp to let it be autogenerated.
      data.sender = undefined;  //  Supresses the sender to always consider it as the socket client.
      let message = Message.create(data);
      message.sender = user;
      if (data.channel) {
				message.send(data.channel);
        // message.channel = await Channel.findOneBy(data.channel);
        // if (!message.channel) {
        //   console.log('Message channel was not found !');
        //   return this.error(client, "Message channel was not found !");
        // }
				// const chanUser = await ChannelUser.findOneBy({channel: message.channel, user: user} as FindOptionsWhere<ChannelUser>);
        // if (!chanUser || !chanUser.canSpeak())
        //   return this.error(client, "You cannot speak in this channel !");
        // message = await message.save();
				// this.ioServ.channelEmit(message.channel, 'msg', message);
				// return message;
      }
      else if (data.recipient) {
        const recipient = await User.findOneBy(data.recipient);
        if (!recipient) {
          console.log('Message recipient was not found !');
          return this.error(client, "Message Recipient was not found !");
        }
				await message.send(await Channel.getDirectChannel(recipient, user, false));
				return message.send(await Channel.getDirectChannel(user, recipient, true));
        // message.channel = await Channel.getDirectChannel(recipient, user, false);
				// this.io.in(channelRoomPrefix + message.channel.id).emit('msg', JSON.stringify(await message.save()));
        // message.channel = await Channel.getDirectChannel(user, recipient, true);
				// message = await message.save();
				// this.io.in(channelRoomPrefix + message.channel.id).emit('msg', JSON.stringify(message));
				// return message;
      }
      else
        return this.error(client, "Invalid message submitted");
    }
    catch (e) {
      this.error(client, e.name + " : " + e.message);
      console.error("[ERROR] " + e.stack)
    }
  }

  @SubscribeMessage('join')
  async join(client: Socket, data: any) {
    console.log(data);
		return data;
  }

  @SubscribeMessage('chanlist')
  async chanlist(client: Socket, data: any) {
    console.log(data);
  }

  @SubscribeMessage('publiclist')
  async publiclist(client: Socket, data: any) {
    console.log(data);
  }

  @SubscribeMessage('userlist')
  async joinedlist(client: Socket, data: any) {
    console.log(data);
  }

  @SubscribeMessage('invitelist') 
  async invitelist(client: Socket, data: any) {
    console.log(data);
  }

  @SubscribeMessage('names')
  async names(client: Socket, data: any) {
    console.log(data);
  }

  @SubscribeMessage('mode')
  async mode(client: Socket, data: any) {
    console.log(data);
  }

}
