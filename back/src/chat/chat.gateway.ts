import { WebSocketGateway, WebSocketServer, SubscribeMessage, OnGatewayConnection, OnGatewayDisconnect, WsException } from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Channel } from 'src/entities/channel.entity';
import { Message } from 'src/entities/message.entity';
import { User } from 'src/entities/user.entity';

const channelRoomPrefix = "channel_";
const pingTimeout = 60000;

@WebSocketGateway({ transports: ['websocket'] })
export class ChatGateway implements OnGatewayConnection, OnGatewayDisconnect {

  @WebSocketServer() private io: Server;

  async handleConnection(client: Socket) {
    const user = await User.findOneBy({ft_login: (client.request as any).user});
    client.data.login = user.ft_login;
    console.log('Websocket Client Connected : ' + user.ft_login);
    user.socket = client.id;
    user.status = User.Status.ONLINE;
    user.save();

    client.data.pingOK = true;
    this.ping(client);
  }

  async handleDisconnect(client: Socket) {
    const user = await User.findOneBy({ft_login: (client.request as any).user});
    console.log('Websocket Client Disconnected : ' + user.ft_login);
    user.socket = null;
    user.status = User.Status.OFFLINE;
    user.save();
  }

  async ping(client: Socket) {
    if (!client.data.pingOK)
      client.disconnect(true);
    else {
      client.data.pingOK = false;
      client.emit('ping');
      setTimeout(() => {
        this.ping(client)
      }, pingTimeout);
    }
  }

  async error(client: Socket, msg: string = ''): Promise<any> {
    client.emit('error', msg);
    return null;
  }

  //  Processes clients ping responses.
  @SubscribeMessage('pong')
  async pong(client: Socket) {
    client.data.pingOK = true;
  }

  //  ********** CORE MESSAGING SERVICE **********

  //  Processes a new message sent by a client (either to a channel or directly to a username)
  //  A Message entity in JSON format is expected as data.
  //
  //  For a direct message, omit channel and set the message <recipient> property as a partial User ( with a user login for example )
  //
  @SubscribeMessage('msg')
  async msg(client: Socket, rawData: string): Promise<Message> {
    try {
      const user = await User.findOneBy({ft_login: client.data.login});
      const data = JSON.parse(rawData);
      data.id = undefined;  //  Supresses the message id to always consider it as a new message.
      data.time = undefined;  //  Supresses the message timestamp to let it be autogenerated.
      data.sender = undefined;  //  Supresses the sender to always consider it as the socket client.
      const message = Message.create(data);
      message.sender = user;
      if (data.channel) {
        message.channel = await Channel.findOne({where: data.channel});
        if (!message.channel) {
          console.log('Message channel was not found !');
          return this.error(client, "Message channel was not found !");
        }
        //  Check if ok to send message to this channel.
        console.log(await message.channel.canSpeak(user));
        if (!message.channel.canSpeak(user))
          return this.error(client, "You cannot speak in this channel !");
        //  Channel message process here.
        return await Message.save(message);
      }
      else if (data.recipient) {
        console.log('direct mode');
        const recipient = await User.findOne({where: data.recipient});
        if (!recipient) {
          console.log('Message recipient was not found !');
          return this.error(client, "Message Recipient was not found !");
        }
        message.channel = await Channel.getDirectChannel(recipient, user, false);
        await message.save();
       // this.io.socket
        message.channel = await Channel.getDirectChannel(user, recipient, true);
        return (message.save());
      }
      else
        return this.error(client, "Invalid message submitted");
    }
    catch (e) {
      this.error(client, e.name + " : " + e.message);
      console.error("[ERROR] " + e.stack)
    }
  }

  @SubscribeMessage('chanlist')
  async chanlist(client: Socket, rawData: string) {
    console.log(JSON.parse(rawData));
  }

  @SubscribeMessage('publiclist')
  async publiclist(client: Socket, rawData: string) {
    console.log(JSON.parse(rawData));
  }

  @SubscribeMessage('userlist')
  async joinedlist(client: Socket, rawData: string) {
    console.log(JSON.parse(rawData));
  }

  @SubscribeMessage('invitelist')
  async invitelist(client: Socket, rawData: string) {
    console.log(JSON.parse(rawData));
  }

  @SubscribeMessage('names')
  async names(client: Socket, rawData: string) {
    console.log(JSON.parse(rawData));
  }

  //  For
  @SubscribeMessage('mode')
  async mode(client: Socket, rawData: string) {
    console.log(JSON.parse(rawData));
  }

}
